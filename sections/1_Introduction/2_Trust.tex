\section{\trust{}}

After single-threaded performance plateaued a decade or more ago, programmers have diverted their attention to 
making multi-threaded applications. This gives rise to the problem of synchronizing many threads as they access 
the same data for correctness and making it efficient to not lose too much performance when compared to single 
threaded applications. Today locks dominate this paradigm to the extent that there are hardware mechanisms in 
place to make the use of locking easier and more efficient. Hardware Lock Elision \cite{10.1145/2517327.2442552} and 
support for atomic increment instructions are examples of such mechanisms. However, a delegation based programming 
model can offer better performance than a locking based one \cite{ffwd,ahmad2024trust,rcl}.

We present \trust{} (pronounced {\it trust-tee}), a programming abstraction and runtime system which 
provides safe, high-performance access to a shared object (or $property$) of type $T$. Briefly, a \trust{} 
provides a family of functions of the form: $$apply(c:FnOnce(\&mut~T)\rightarrow U)\rightarrow U,$$ which 
causes the closure $c$ to be safely applied to the property (of type $T$), and returns the return value 
(of type $U$) of the closure to the caller. Here, $FnOnce$ denotes a category of Rust closure types, and 
$\&mut$ denotes a mutable reference. (A matching set of non-blocking functions is also provided, which 
instead executes a callback closure with the return value.)

Critically, access to the property is only available through the \trust{} API, which taken together with 
the Rust ownership model and borrow checker eliminates any potential for race conditions, given a correct 
implementation of {\it apply}. Our implementation of \trust{} uses pure delegation. However, the design of 
the API also permits lock-based implementations, as well as hybrids. 

\begin{table*}[ht]
  \begin{subtable}[t]{.54\textwidth}
    \begin{lstlisting}  
let ct = local_trustee().entrust(17);
let ct2 = ct.clone();
let thread = spawn(move || { 
 ct2.apply(|c| *c+=1);
});
ct.apply(|c| *c+=1);
thread.join()?;
assert!(ct.apply(|c| *c) == 19);
\end{lstlisting}   
\caption{Example using \trust{}.}
    \label{tab:minimal_threads}
  \end{subtable}
  ~
  \begin{subtable}[t]{.5\textwidth}
    \begin{lstlisting}  
let cm = Arc::new(Mutex::new(17));
let cm2 = cm.clone();
let thread = spawn(move || { 
 *(cm2.lock()?) += 1;
});
*(cm.lock()?) += 1;
thread.join()?;
assert!(*cm.lock()? == 19);
\end{lstlisting}
    \caption{The same program using standard Rust primitives. }
    \label{tab:minimal_mutex}
  \end{subtable}
  \caption{Minimal multi-threaded \trust{} example. Reference counting ensures that the property remains in memory 
  	until the last \trust{} referencing the property drops. }
\end{table*}

Table~\ref{tab:minimal_threads} shows an example where a counter is incremented by two different threads.
Here, the {\tt clone()} call on {\tt ct} (line 2) clones the trust, but not the property; instead a reference count 
is incremented for the shared property, analogous to {\tt Arc::clone()}.
On line 3, a newly spawned thread takes ownership of {\tt ct2}, in the Rust sense of the word, then uses this to 
apply a closure (line 4).
When the thread exits, {\tt ct2} is dropped, decrementing the reference count, by means of a delegation request.
When the last trust of a property is dropped, the property is dropped as well. For readers unfamiliar with Rust, 
Table~\ref{tab:minimal_mutex} illustrates the rough equivalent of Table~\ref{tab:minimal_threads}, but using conventional Rust 
primitives instead of \trust{}. Note the similarity in terms of legibility and verbosity. 

Beyond the API, \trust{} provides a runtime for scheduling request transmission and processing, as well as 
lightweight user threads ($fibers$ below). This allows each OS thread to serve both as a Trustee, processing 
incoming requests, and a client. Multiple outstanding requests can be issued either by concurrent 
synchronous fibers or an asynchronous programming style. \trust{} achieves performance improvements up to 
22$\times$ vs. the best locks on congested micro-benchmarks and up to 9$\times$ on benchmarking workloads vs. 
stock {\tt memcached}.
% While \trust{} provides some value in isolation, its full power is only apparent when combined with a runtime, 
% providing additional concurrency, request scheduling and more. Now, depending on the current context as well as 
% compile-time settings, the call to {\it apply()} may result in a very wide range of outcomes including (a) 
% accessing the property directly, (b) acquiring a lock, then accessing the property, (c) sending a delegation 
% request to a different thread, which in turn accesses the property, and/or (d) suspending the current thread and 
% resuming another. 

% The primary contributions of this paper are as follows:


% \begin{itemize}
%   \setlength{\itemsep}{0em}
% 	\item Trust$<$T$>$: a model for efficient, multi-threaded, delegation-based programming with shared objects leveraging the Rust type system.
% 	\item A new delegation channel design, for delegating a variable number of arbitrary-sized and extremely flexible requests per message. 
% 	\item Two efficient mechanisms for supporting nested delegation requests, a key missing ingredient in previous work on delegation.
% 	%\item A hybrid delegation/locking design, combining the excellent scalability of delegation with the low latency of uncontended locks. ????????
% 	%\item A delegation channel, featuring shared/lossy request lines, drastically reducing server polling overhead. ????????
% 	%\item The design and implementation of many standard synchronization primitives without the use of atomic instructions. 
% 	\item Performance improvements up to 22$\times$ vs. the best locks on congested micro-benchmarks
% 	\item Delegation performance consistently matching uncongested locks, given sufficient available parallelism
% 	\item Memcached performance improvements of up to 9$\times$ on benchmarking workloads vs. stock {\tt memcached}.
% 	%\item An implementation which matches the efficiency of prior work on delegation with mutable global variables, in C.
% 	%\item Evaluation of \trust{} vs. locking on a range of applications, ranging from microbenchmarks to production software. 
% \end{itemize}